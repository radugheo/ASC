.data	formatScanfInt: .asciz "%d"	formatPrintfInt: .asciz "%d "	formatNewLine: .asciz "\n"		valueOne: .long 1		v: .space 150	n: .space 4	N_3: .space 4	m: .space 4	k: .space 4	i: .space 4	temp: .space 4	ap: .space 4	xdek: .space 4	xdei: .space 4	aux: .space 4	aux2: .space 4	.textprint:	cmp %ecx, N_3	je bkt_post_afis		pushl %ebx	movl (%esi, %ecx, 4), %eax		pushl %ecx	pushl %eax	pushl $formatPrintfInt	call printf	popl %ebx	popl %ebx	popl %ecx		popl %ebx	incl %ecx	jmp printverif:	pushl %ebp	movl %esp, %ebp		movl 8(%ebp), %eax	movl %eax, ket_verif_for:	cmp %ecx, N_3	je et_verif_dupa_for	pushl %ecx	mov $v, %esi	movl k, %ecx		pushl %ebx	movl (%esi, %ecx, 4), %ebx	movl %ebx, xdek	popl %ebx	popl %ecx	mov $v, %esi	movl (%esi, %ecx, 4), %ebx	cmp xdek, %ebx	je et_verif_cresc_apet_verif_cont:		incl %ecx	jmp et_verif_foret_verif_cresc_ap:	incl ap	jmp et_verif_contet_verif_dupa_for:	movl ap, %edx	cmp $3, %edx	jg et_verif_return_false	/*i=k-1=ecx*/	/*i>=k-m=aux*/		movl k, %ecx	decl %ecx	movl k, %edx	subl m, %edx	movl %edx, aux	/*et_verif_for_1:	cmp %ecx, aux	jg et_verif_return_true		pushl %ecx	pushl %eax	mov $v, %esi	movl k, %ecx		movl (%esi, %ecx, 4), %eax	movl %eax, xdek	popl %eax	popl %ecx	mov $v, %esi	movl (%esi, %ecx, 4), %edx	cmp xdek, %edx	je et_verif_return_false /*AICI E PROBLEMA, CU TRUE MERGE SI CU FALSE NUet_verif_for_1_cont:	decl %ecx	jmp et_verif_for_1/*et_verif_for_2_preg:	pushl %eax	movl k, %eax	incl %eax	movl %eax, %ecx	popl %eax	pushl %eax	movl k, %eax	addl m, %eax	movl %eax, aux	popl %eaxet_verif_for_2:	cmp %ecx, aux	jl et_verif_return_true		pushl %ecx	mov $v, %esi	movl k, %ecx		pushl %ebx	movl (%esi, %ecx, 4), %ebx	movl %ebx, xdek	popl %ebx	popl %ecx	mov $v, %esi	movl (%esi, %ecx, 4), %ebx	cmp xdek, %ebx	je et_verif_return_falseet_verif_for_2_cont:	incl %ecx	jmp et_verif_for_2*/et_verif_return_true:	movl $1, %eax	popl %ebp	retet_verif_return_false:	movl $0, %eax	popl %ebp	retbkt:	pushl %ebp	movl %esp, %ebp		movl 8(%ebp), %eax	movl %eax, k	movl k, %ecx	mov $v, %esi    movl (%esi, %ecx, 4), %eax	cmp $0, %eax	jg bkt_next		movl $1, i	pushl ibkt_for:	popl i	movl i, %ecx		cmp %ecx, n	jl bkt_exit		pushl %ecx	mov $v, %esi	movl k, %ecx	movl i, %eax	movl %eax, (%esi, %ecx, 4)	popl %ecx	incl i	pushl i	pushl %eax	movl $0, %eax	movl %eax, ap	popl %eax	xorl %ecx, %ecx	pushl k	call verif	popl %ebx	cmp $1, %eax	je et_verif_este_true	mov $v, %esi	movl k, %ecx	movl $0, %eax	movl %eax, (%esi, %ecx, 4)	jmp bkt_foret_verif_este_true:	xorl %ecx, %ecx	movl k, %edx	cmp N_3, %edx /*if (k == 3*n) print(); return;*/	je et_print		jmp bkt_nextet_print:	xorl %ecx, %ecx	call print	xorl %ecx, %ecxbkt_next:    incl %ecx	pushl %ecx	call bkt	popl %ecx	subl $1, %ecx	movl %ecx, k	bkt_exit:	popl %ebp	retprint_exit:	jmp et_exitbkt_post_afis:	pushl %ecx	pushl %ebx	pushl $formatNewLine	call printf	popl %ebx	popl %ebx	popl %ecx	jmp print_exit.global mainmain:	mov $v, %esi        pushl %ebx	pushl %ecx	pushl $n	pushl $formatScanfInt	call scanf	popl %ebx	popl %ebx	popl %ecx		movl n, %eax	addl n, %eax	addl n, %eax	movl %eax, N_3		pushl %ecx	pushl $m	pushl $formatScanfInt	call scanf	popl %ebx	popl %ebx	popl %ecx	    popl %ebx	xorl %ecx, %ecxread_vector:	cmp %ecx, N_3	je read_exit		pushl %ecx	pushl $temp	pushl $formatScanfInt	call scanf	popl %ebx	popl %ebx	popl %ecx	movl temp, %eax	movl %eax, (%esi, %ecx, 4)		incl %ecx	jmp read_vectorread_exit:    /*popl %ebx*/    xorl %ecx, %ecx	pushl %ecx    pushl $0	call bkt	popl %ebx	popl %ecx		et_exit:	pushl %ecx	pushl $formatNewLine	call printf	popl %ebx	popl %ecx		movl $1, %eax	movl $0, %ebx	int $0x80